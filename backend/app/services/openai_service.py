import os
from openai import AsyncOpenAI
from typing import Dict, Any
import json
import re

# Check if OpenAI API key is available
api_key = os.getenv("OPENAI_API_KEY")
if api_key:
    client = AsyncOpenAI(api_key=api_key)
else:
    client = None
    print("Warning: OPENAI_API_KEY not found. Using mock responses for testing.")

def clean_json_string(json_str: str) -> str:
    """Clean JSON string by removing control characters and fixing common issues"""
    # Remove control characters
    json_str = re.sub(r'[\x00-\x1f\x7f-\x9f]', '', json_str)
    # Remove any leading/trailing whitespace
    json_str = json_str.strip()
    # If the response starts with ```json and ends with ```, remove them
    if json_str.startswith('```json'):
        json_str = json_str[7:]
    if json_str.endswith('```'):
        json_str = json_str[:-3]
    json_str = json_str.strip()
    return json_str

async def generate_story(prompt: str, genre: str = "Drama", tone: str = "Serious") -> Dict[str, Any]:
    # If no API key, return mock data
    if not client:
        return {
            "title": f"Mock Story: {prompt[:30]}...",
            "content": f"This is a mock story generated for testing purposes. The original prompt was: '{prompt}'. Genre: {genre}, Tone: {tone}. In a real implementation, this would be generated by OpenAI's GPT model with proper storytelling, character development, and engaging narrative structure.",
            "tags": ["mock", "test", genre.lower(), tone.lower(), "story"]
        }
    
    # Map frontend genre values to backend style values
    genre_mapping = {
        "Drama": "professional",
        "Comedy": "humorous", 
        "Romance": "creative",
        "Mystery": "professional",
        "Horror": "creative",
        "Adventure": "creative",
        "Sci-Fi": "creative",
        "Fantasy": "creative"
    }
    
    # Map frontend tone values to writing style
    tone_mapping = {
        "Funny": "humorous",
        "Serious": "professional",
        "Mysterious": "creative",
        "Emotional": "creative",
        "Inspirational": "professional",
        "Dramatic": "professional",
        "Casual": "casual",
        "Professional": "professional"
    }
    
    # Use mapped values or defaults
    backend_style = genre_mapping.get(genre, "casual")
    writing_tone = tone_mapping.get(tone, "casual")
    
    # Define style prompts
    style_prompts = {
        "casual": "Write a casual, conversational story that's easy to read and engaging. Include a catchy title.",
        "professional": "Write a professional, well-structured story suitable for business or formal contexts. Include a clear title.",
        "creative": "Write a creative, imaginative story that's unique and engaging. Include a creative title.",
        "humorous": "Write a funny, entertaining story that will make readers laugh. Include a witty title."
    }
    
    # Create a comprehensive prompt that combines genre, tone, and user prompt
    system_prompt = f"""You are a professional story writer. 
    Write a {genre.lower()} story with a {tone.lower()} tone.
    {style_prompts.get(backend_style, style_prompts["casual"])}
    The story should be about 500 words and include engaging characters and plot development.
    Include relevant tags at the end.
    Format the response as a single line of valid JSON with these fields: 'title', 'content', and 'tags' (an array of strings). Do not include any extra text, explanations, or formatting. Only output the JSON object."""
    
    try:
        response = await client.chat.completions.create(
            model="gpt-4",  # or "gpt-3.5-turbo" for faster/cheaper results
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": prompt}
            ]
        )
        
        # Get the response content
        response_content = response.choices[0].message.content
        
        # Clean the JSON string
        cleaned_json = clean_json_string(response_content)
        
        # Parse the JSON response
        try:
            story_data = json.loads(cleaned_json)
        except json.JSONDecodeError as e:
            # If JSON parsing fails, create a fallback response
            print(f"JSON parsing failed: {e}")
            print(f"Response content: {response_content}")
            story_data = {
                "title": f"{genre} Story: {prompt[:30]}...",
                "content": response_content,
                "tags": [genre.lower(), tone.lower(), "story"]
            }
        
        return story_data
        
    except Exception as e:
        raise Exception(f"Error generating story: {str(e)}")

async def generate_image(prompt: str, style: str = "realistic", size: str = "1024x1024") -> str:
    # If no API key, return mock image URL
    if not client:
        return "https://via.placeholder.com/1024x1024/4F46E5/FFFFFF?text=Mock+Image"
    
    try:
        response = await client.images.generate(
            model="dall-e-3",
            prompt=f"Create a {style} style image: {prompt}",
            size=size,
            quality="standard",
            n=1,
        )
        return response.data[0].url
    except Exception as e:
        raise Exception(f"Error generating image: {str(e)}")
